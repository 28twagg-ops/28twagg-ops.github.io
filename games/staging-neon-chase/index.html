<!-- 
Theme: Cyberpunk / Sci-Fi
Font: Orbitron
Style: Neon-noir, high contrast, glowing grid aesthetic with digital glitch effects
Colors: 
  - Background: #050010 (Dark Cyber Purple)
  - Walls: #00FF41 (Matrix Green)
  - Player (Data Orb): #00F0FF (Cyan)
  - Drones: #FF0055 (Red), #FF9900 (Orange), #CC00FF (Purple), #FFFF00 (Yellow)
Dimensions: 456px width x 480px height (Calculated as 19 columns * 24px tile size by 20 rows * 24px tile size).
Location: The game area is contained within the HTML element with id="game-container".
Purpose: AI implementation for themes
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Maze Chase</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            background-color: #050010; /* Dark Cyber Purple */
            color: #fff;
            font-family: 'Orbitron', sans-serif; /* Sci-fi font */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
            border: 4px solid #333;
            border-radius: 8px;
            background-color: #000;
        }

        canvas {
            display: block;
            background-color: #080808;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
            z-index: 10;
        }

        #score-display span { color: #00F0FF; }
        #lives-display span { color: #FF0055; }
        #level-display span { color: #00FF41; }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 0, 16, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            text-align: center;
        }

        h1 {
            color: #00F0FF;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00F0FF;
            letter-spacing: 2px;
            line-height: 1.5;
        }

        p {
            font-size: 12px;
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 20px;
            max-width: 80%;
        }

        button {
            background: transparent;
            color: #00FF41;
            border: 2px solid #00FF41;
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
            transition: all 0.2s;
            margin-top: 10px;
            text-transform: uppercase;
        }

        button:hover {
            background: #00FF41;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        /* Input Styles */
        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        input#initials-input {
            background: #000;
            border: 2px solid #00F0FF;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            width: 120px;
            text-align: center;
            padding: 10px;
            text-transform: uppercase;
            outline: none;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
        }

        .hidden {
            display: none !important;
        }
        
        .mobile-hint {
            margin-top: 10px;
            font-size: 10px;
            color: #666;
            display: none;
        }
        
        @media (max-width: 600px) {
            .mobile-hint { display: block; }
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div class="hud-bar">
                <div id="score-display">BITS: <span id="score-val">0</span></div>
                <div id="level-display">ZONE: <span id="level-val">1</span></div>
                <div id="high-score">TOP: <span id="high-score-val">0</span></div>
            </div>
            <div class="hud-bar" style="justify-content: flex-end;">
                 <div id="lives-display">UNITS: <span id="lives-val">3</span></div>
            </div>
        </div>

        <div id="overlay">
            <!-- Content injected by JS -->
        </div>
    </div>

<script>
/**
 * LEADERBOARD SYSTEM (V3 for new game)
 */
const Leaderboard = {
    key: 'neon_chase_leaderboard_v1', 
    data: [],
    
    load: function() {
        const stored = localStorage.getItem(this.key);
        if (stored) {
            try {
                this.data = JSON.parse(stored);
            } catch(e) {
                this.createDefaults();
            }
        } else {
            this.createDefaults();
        }
        this.data.sort((a, b) => b.score - a.score);
    },

    createDefaults: function() {
        this.data = [
            {name: 'NEO', score: 2000},
            {name: 'TRN', score: 1500},
            {name: 'CYB', score: 1000},
            {name: 'BOT', score: 500},
            {name: 'CPU', score: 200}
        ];
        this.save();
    },

    save: function() {
        localStorage.setItem(this.key, JSON.stringify(this.data));
    },

    isHighScore: function(score) {
        if (this.data.length < 5) return true;
        return score > this.data[this.data.length - 1].score;
    },

    add: function(name, score) {
        this.data.push({ name: name.toUpperCase().substring(0, 3), score: parseInt(score) });
        this.data.sort((a, b) => b.score - a.score);
        this.data = this.data.slice(0, 5);
        this.save();
    },

    getTopScore: function() {
        return this.data.length > 0 ? this.data[0].score : 0;
    }
};

/**
 * AUDIO ENGINE
 * Updated sounds for a "tech" feel
 */
const AudioEngine = (() => {
    let ctx = null;
    let enabled = false;

    const init = () => {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            enabled = true;
        } else if (ctx.state === 'suspended') {
            ctx.resume();
        }
    };

    const playTone = (freq, type, duration, vol = 0.1) => {
        if (!enabled || !ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    };

    return {
        init,
        step: () => { // "Tick" instead of Waka
            if (!enabled) return;
            playTone(800, 'square', 0.05, 0.02);
        },
        eatDrone: () => playTone(1200, 'sawtooth', 0.1, 0.1),
        crash: () => {
            if (!enabled) return;
            for(let i=0; i<5; i++) {
                setTimeout(() => playTone(100 - (i*20), 'sawtooth', 0.2, 0.2), i*50);
            }
        },
        start: () => {
            if (!enabled) return;
            playTone(440, 'sine', 0.1, 0.1);
            setTimeout(() => playTone(880, 'sine', 0.3, 0.1), 150);
        }
    };
})();

const TILE_SIZE = 24; 
const WALL_COLOR = '#00FF41'; // Matrix Green
const GATE_COLOR = '#FF0055';

// NEW CUSTOM MAZE LAYOUT
// 0: Empty, 1: Wall, 2: Bit, 3: Power Up, 4: Drone Gate
const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,2,1],
    [1,3,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,4,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,2,2,2,2,2,0,0,1,0,1,0,0,2,2,2,2,2,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
    [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
    [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
    [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const COLS = MAP[0].length;
const ROWS = MAP.length;

// Game State
let canvas, ctx;
let gameInterval;
let score = 0;
let level = 1;
let highScore = 0;
let lives = 3;
let gameState = 'START'; 
let powerModeTime = 0;
let flashTimer = 0;

// Entities
let player = {};
let drones = [];
let particles = [];
let bits = [];

// Input
let keys = {};
let nextDir = { x: 0, y: 0 }; 
let touchStartX = 0;
let touchStartY = 0;

/**
 * CLASSES 
 */
class Entity {
    constructor(x, y, color) {
        this.x = x * TILE_SIZE + TILE_SIZE/2;
        this.y = y * TILE_SIZE + TILE_SIZE/2;
        this.color = color;
        this.dir = { x: 0, y: 0 };
        this.speed = 2;
        this.radius = TILE_SIZE * 0.4;
    }
    getGridPos() {
        return { c: Math.floor(this.x / TILE_SIZE), r: Math.floor(this.y / TILE_SIZE) };
    }
    isCentered() {
        const threshold = 1.0;
        const centerX = (this.getGridPos().c * TILE_SIZE) + TILE_SIZE/2;
        const centerY = (this.getGridPos().r * TILE_SIZE) + TILE_SIZE/2;
        return Math.abs(this.x - centerX) < threshold && Math.abs(this.y - centerY) < threshold;
    }
    snapToGrid() {
        const p = this.getGridPos();
        this.x = p.c * TILE_SIZE + TILE_SIZE/2;
        this.y = p.r * TILE_SIZE + TILE_SIZE/2;
    }
    canMove(dx, dy) {
        const p = this.getGridPos();
        const nextC = p.c + dx;
        const nextR = p.r + dy;
        if (nextC < 0 || nextC >= COLS) return true;
        if (nextR >= 0 && nextR < ROWS) {
            const tile = MAP[nextR][nextC];
            return tile !== 1 && tile !== 4;
        }
        return false;
    }
    move() {
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, '#00F0FF'); // Cyan
        this.pulse = 0;
    }
    update() {
        if (this.isCentered()) {
            if (nextDir.x !== 0 || nextDir.y !== 0) {
                if (this.canMove(nextDir.x, nextDir.y)) {
                    this.snapToGrid();
                    this.dir = { ...nextDir };
                }
            }
            if (!this.canMove(this.dir.x, this.dir.y)) {
                this.snapToGrid();
                this.dir = { x: 0, y: 0 };
            }
        }
        this.move();
        
        // Step Sound
        if ((this.dir.x !== 0 || this.dir.y !== 0) && Math.random() < 0.1) {
             AudioEngine.step();
        }

        // Collect Bits
        const p = this.getGridPos();
        if (p.r >= 0 && p.r < ROWS && p.c >= 0 && p.c < COLS) {
            const bitIndex = bits.findIndex(b => b.c === p.c && b.r === p.r);
            if (bitIndex !== -1) {
                const b = bits[bitIndex];
                bits.splice(bitIndex, 1);
                if (b.type === 2) score += 10;
                else if (b.type === 3) { score += 50; activatePowerMode(); }
                if (bits.length === 0) winGame();
            }
        }
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
    }
}

class Drone extends Entity {
    constructor(x, y, color, type) {
        super(x, y, color);
        this.originalColor = color;
        this.type = type;
        let baseSpeed = 1.5;
        if (level >= 2) baseSpeed = 2.0;
        if (level >= 5) baseSpeed = 2.4; 
        this.speed = baseSpeed; 
        this.mode = 'SCATTER';
        this.dir = { x: 0, y: 0 };
        this.inHouse = true;
    }
    update() {
        if (this.isCentered()) {
            const options = [];
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            dirs.forEach(d => {
                if (d.x === -this.dir.x && d.y === -this.dir.y && this.dir.x !==0) return;
                const p = this.getGridPos();
                const nextC = p.c + d.x;
                const nextR = p.r + d.y;
                if (nextC >=0 && nextC < COLS && nextR >=0 && nextR < ROWS) {
                    const tile = MAP[nextR][nextC];
                    if (tile === 1) return;
                    if (tile === 4 && !this.inHouse) return;
                    options.push(d);
                }
            });
            if (options.length > 0) {
                if (this.mode === 'FRIGHTENED') {
                    this.dir = options[Math.floor(Math.random() * options.length)];
                } else {
                    if (this.mode === 'CHASE' && Math.random() > 0.4) {
                        let bestDir = options[0];
                        let minDist = 999999;
                        options.forEach(opt => {
                            const tx = (this.getGridPos().c + opt.x) * TILE_SIZE;
                            const ty = (this.getGridPos().r + opt.y) * TILE_SIZE;
                            const dist = Math.hypot(tx - player.x, ty - player.y);
                            if (dist < minDist) { minDist = dist; bestDir = opt; }
                        });
                        this.dir = bestDir;
                    } else {
                         this.dir = options[Math.floor(Math.random() * options.length)];
                    }
                }
                this.snapToGrid();
            } else {
                this.dir = { x: -this.dir.x, y: -this.dir.y };
            }
        }
        this.move();
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < TILE_SIZE) {
            if (this.mode === 'FRIGHTENED') {
                AudioEngine.eatDrone();
                this.reset();
                score += 200;
                createParticles(this.x, this.y, this.originalColor);
            } else if (this.mode !== 'EATEN') {
                killPlayer();
            }
        }
    }
    reset() {
        this.x = 9 * TILE_SIZE + TILE_SIZE/2;
        this.y = 8 * TILE_SIZE + TILE_SIZE/2;
        this.mode = 'CHASE';
        this.dir = {x:0, y:-1};
        this.inHouse = true;
        let releaseTime = Math.max(500, 2000 - (level * 200));
        setTimeout(() => { this.inHouse = false; }, releaseTime);
    }
    draw() {
        const color = (this.mode === 'FRIGHTENED') ? 
                      ((flashTimer > 0 && Math.floor(Date.now() / 200) % 2 === 0) ? '#fff' : '#00f') : 
                      this.originalColor;
        ctx.fillStyle = color;
        
        // Draw Drone as Triangle
        const r = this.radius;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - r);
        ctx.lineTo(this.x + r, this.y + r);
        ctx.lineTo(this.x - r, this.y + r);
        ctx.closePath();
        ctx.fill();
        
        // "Eye"
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, r/3, 0, Math.PI*2);
        ctx.fill();
    }
}

/**
 * GAME LOGIC
 */

function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;
    
    Leaderboard.load();
    highScore = Leaderboard.getTopScore();
    
    // UI Event Listeners
    window.addEventListener('keydown', handleKey);
    window.addEventListener('touchstart', handleTouchStart, {passive: false});
    window.addEventListener('touchend', handleTouchEnd, {passive: false});

    showStartScreen();
    resetLevel();
    draw();
}

function showStartScreen() {
    gameState = 'START';
    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    
    // Leaderboard display removed
    ov.innerHTML = `
        <h1>NEON CHASE</h1>
        <p>ARROWS / SWIPE to Move<br>Collect Bits & Hack Drones</p>
        <button onclick="startGame()">INITIATE</button>
    `;
}

function showInputScreen() {
    gameState = 'INPUT_SCORE';
    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    
    ov.innerHTML = `
        <h1 style="color:#00ff00; font-size:20px;">NEW RECORD!</h1>
        <p>BITS COLLECTED: ${score}</p>
        <div class="input-group">
            <input type="text" id="initials-input" maxlength="3" placeholder="---" autocomplete="off" autofocus>
            <button onclick="submitScore()">UPLOAD</button>
        </div>
    `;
    
    setTimeout(() => {
        const inp = document.getElementById('initials-input');
        if(inp) inp.focus();
    }, 100);
}

function submitScore() {
    const input = document.getElementById('initials-input');
    let name = input.value.trim() || "UNK";
    Leaderboard.add(name, score);
    highScore = Leaderboard.getTopScore();
    showStartScreen();
}

function resetLevel() {
    bits = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (MAP[r][c] === 2) bits.push({c, r, type: 2});
            if (MAP[r][c] === 3) bits.push({c, r, type: 3});
        }
    }
    resetEntities();
}

function resetEntities() {
    player = new Player(9, 15);
    drones = [
        new Drone(9, 8, '#FF0055', 0), // Red
        new Drone(8, 9, '#FF9900', 1), // Orange
        new Drone(10, 9, '#CC00FF', 2), // Purple
        new Drone(9, 9, '#FFFF00', 3)  // Yellow
    ];
    drones[0].inHouse = false;
    drones[0].dir = {x: -1, y: 0};
    nextDir = { x: 0, y: 0 };
}

function startGame() {
    AudioEngine.init();
    AudioEngine.start();
    document.getElementById('overlay').classList.add('hidden');
    score = 0;
    lives = 3;
    level = 1;
    updateUI();
    gameState = 'PLAY';
    resetLevel();
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 1000/60);
}

function winGame() {
    gameState = 'LEVEL_TRANSITION';
    AudioEngine.start();
    level++;
    
    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.innerHTML = `<h1>ZONE ${level}</h1><p>SYNCING...</p>`;
    
    clearInterval(gameInterval);
    setTimeout(() => {
        ov.classList.add('hidden');
        gameState = 'PLAY';
        resetLevel();
        gameInterval = setInterval(gameLoop, 1000/60);
    }, 3000);
}

function gameOver() {
    gameState = 'GAMEOVER';
    clearInterval(gameInterval);
    
    if (Leaderboard.isHighScore(score)) {
        setTimeout(showInputScreen, 1500);
    } else {
        const ov = document.getElementById('overlay');
        ov.classList.remove('hidden');
        ov.innerHTML = `
            <h1 style="color:#FF0055">SYSTEM FAILURE</h1>
            <p>BITS: ${score}</p>
            <button onclick="showStartScreen()">REBOOT</button>
        `;
    }
}

function killPlayer() {
    lives--;
    updateUI();
    AudioEngine.crash();
    createParticles(player.x, player.y, '#00F0FF');
    if (lives <= 0) {
        gameOver();
    } else {
        resetEntities();
    }
}

function activatePowerMode() {
    let duration = Math.max(120, 600 - ((level-1) * 60));
    powerModeTime = duration;
    flashTimer = 0;
    drones.forEach(g => { if (g.mode !== 'EATEN') g.mode = 'FRIGHTENED'; });
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 30,
            color: color
        });
    }
}

function updateUI() {
    document.getElementById('score-val').textContent = score;
    document.getElementById('high-score-val').textContent = highScore;
    document.getElementById('lives-val').textContent = lives;
    document.getElementById('level-val').textContent = level;
}

function gameLoop() {
    if (gameState !== 'PLAY') return;
    player.update();
    drones.forEach(g => g.update());
    if (powerModeTime > 0) {
        powerModeTime--;
        if (powerModeTime < 120) flashTimer++;
        if (powerModeTime === 0) {
            drones.forEach(g => { if (g.mode === 'FRIGHTENED') g.mode = 'CHASE'; });
        }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }
    updateUI();
    draw();
}

/**
 * RENDERING
 */
function draw() {
    ctx.fillStyle = '#050010'; // Dark bg
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;
            if (MAP[r][c] === 1) {
                ctx.strokeStyle = WALL_COLOR;
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                // Glow effect
                ctx.shadowBlur = 5;
                ctx.shadowColor = WALL_COLOR;
                ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.shadowBlur = 0;
            } else if (MAP[r][c] === 4) {
                ctx.strokeStyle = GATE_COLOR;
                ctx.beginPath();
                ctx.moveTo(x, y + TILE_SIZE/2);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                ctx.stroke();
            }
        }
    }
    
    bits.forEach(b => {
        const x = b.c * TILE_SIZE + TILE_SIZE/2;
        const y = b.r * TILE_SIZE + TILE_SIZE/2;
        ctx.fillStyle = '#00F0FF';
        if (b.type === 2) {
            ctx.fillRect(x-1, y-1, 2, 2);
        } else {
            // Power Up Pulse
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
    
    player.draw();
    drones.forEach(g => g.draw());
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
}

function handleKey(e) {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    if (gameState === 'INPUT_SCORE' && e.key === 'Enter') {
        submitScore();
        return;
    }
    
    // DEVELOPER KEY: 'N' for Next Level
    if (e.key.toLowerCase() === 'n' && gameState === 'PLAY') {
        winGame();
        return;
    }

    switch(e.code) {
        case 'ArrowUp': nextDir = { x: 0, y: -1 }; break;
        case 'ArrowDown': nextDir = { x: 0, y: 1 }; break;
        case 'ArrowLeft': nextDir = { x: -1, y: 0 }; break;
        case 'ArrowRight': nextDir = { x: 1, y: 0 }; break;
    }
}

function handleTouchStart(e) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}

function handleTouchEnd(e) {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) nextDir = dx > 0 ? {x:1, y:0} : {x:-1, y:0};
    } else {
        if (Math.abs(dy) > 30) nextDir = dy > 0 ? {x:0, y:1} : {x:0, y:-1};
    }
}

init();

</script>
</body>
</html>